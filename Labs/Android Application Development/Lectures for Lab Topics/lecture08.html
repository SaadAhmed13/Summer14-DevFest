<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <meta name="generator" content="pandoc">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="db-simple.css" type="text/css">
</head>
<body>
<div id="header">

<div id="sitetitle"><b>Dartmouth CS 65/165</b></div>
<div id="container">
<div id="sitesubtitle"><b>Smartphone Programming</b></div>
<div id="siterightheader"><b>Professor Andrew T. Campbell</b></div>
</div>

<div class="clearer"><!-- --></div>


<hr>
</div>
<h1 id="fragments-and-actonbars">Fragments and ActonBars</h1>
<p>The Android framework contains a number of UI components that allow a common feel to design simple UIs -- one is the ActionBar. These UI components integrate <code>fragments</code> which are associated with a view. Fragments let us build reusable and extensible UIs.</p>
<h2 id="what-this-lecture-will-teach-you">What this lecture will teach you</h2>
<ul>
<li>How to build the ActionTab app, which uses ActionBar and fragments</li>
<li>Fragments</li>
<li>Fragment lifecycle</li>
<li>Container views and fragment layouts</li>
<li>ActionBar</li>
<li>Setting up Menus</li>
<li>Creating the ActionBar with Tabs</li>
<li>Implementing the ActionBar.TabListener interface</li>
<li>What is Context?</li>
</ul>
<h2 id="resources">Resources</h2>
<ul>
<li>Android developers <a href="http://developer.android.com/guide/components/fragments.html">Fragments</a></li>
<li>Android developers <a href="http://developer.android.com/guide/topics/ui/actionbar.html">Action Bar</a></li>
<li>Course book <a href="http://commonsware.com/Android/">The Tactics of Fragments</a> page 279</li>
<li>Course book <a href="http://commonsware.com/Android/">Fragments and Action Bar</a> page 309</li>
</ul>
<h2 id="checkout-the-demo-project">Checkout the demo project</h2>
<ul>
<li>Download the demo the <a href="../code/actionbar.zip">actionbar.zip</a> app specifically designed to go with these notes.</li>
</ul>
<h2 id="actiontab-app">ActionTab app</h2>
<p>ActionTab is a simple application used to demonstrate the use on the ActionBar and fragments. If you click through the tabs you will find to answer to the question - why Dartmouth.</p>
<p>Fragments are associated with the UI. We will develop the ActionTab app to best illustrate how fragments can use Android UI components such as ActionBar (more on that in a moment). The ActionTab app will combine multiple fragments (four in all) in a single activity to build a multi-pane UI. These fragments can be considered self-contained components and could be reused by multiple activities potentially across multiple applications.</p>
<p>The app is made up of 4 tabs and 4 corresponding fragments.</p>
<p>Note, that when the app is shown in landscape the ActionBar is configured differently from the normal portrait view -- Android rearranges the icons visible in the actionbar; that is, in landscape the &quot;add&quot; option is shown as an icon on the actionbar rather than in the drop down, as is the case in portrait mode; we show the landscape below:</p>
<div class="figure">
<img src="images/actiontab.png">
</div>
<p>Play with the app to get a feel for the UI -- cool hey? Simple, compact and a nice way to build up the features and services offered by your app. We will use this ActionBar and fragment combination as part of Lab2.</p>
<p>There is one activity and four fragments in this project:</p>
<ul>
<li>activity: MainActivity.java</li>
<li>fragments: ChatFragment.java, FindFragment.java, MeetFragment.java, PartyFragment.java</li>
<li>layouts: each activity and fragment has a layout</li>
<li>menu: this is <strong>new</strong> the action bar has a menu that is in res/menu/main.xml</li>
</ul>
<h2 id="fragments">Fragments</h2>
<p>Up until now we have used activities as drivers to display views to the screen. The previous example each screen is associated with an activity that is used to render and manage the user interaction with the view. All that changes in this lecture. We move away from activities and start to use fragments -- a fragment is now used to render and manager a particular UI view. Think of fragments as lightweight activities for now. Your application still needs activities but we don't use them to solely render views. Most applications, and ones we will develop, include one or more activity and fragments.</p>
<p>What are fragments?</p>
<ul>
<li>Fragments the parts of application's UI or behavior that are integrated into activities -- a fragment needs an activity to run.</li>
<li>Fragments are flexible and reusable components defined by the programmer</li>
<li>each fragment has its own lifecycle and associated UI (for example, a fragment for the user to enter profile information, another one to render maps).</li>
<li>Fragments present a consistent UI across different apps and devices; fragments are flexible in adapting the user experience across these different environments.</li>
</ul>
<p>In implementation there are considerable differences; for example, an activity has to be specified in the manifest, while fragments do not because they can only exist in the context of an activity and are coupled to the activity state. While fragments are strongly integrated into the UI you can use fragments without a view or UI components. Fragments can implement a number of application behaviors, such as, code to handle listeners, files, database, etc. These types of fragments can be thought of as invisible worker for the activity -- more later on this. For now we will just consider fragments when applied to the UI.</p>
<h2 id="why-use-fragments-over-activities">Why use fragments over activities?</h2>
<p>A fragment is a modular part of an activity. It has its own lifecycle and receives its own input events. Fragments can created, added or removed while the activity is running. Consider a fragment a &quot;sub activity&quot; that you can reuse in different activities. But you could ignore fragments and just use activities if you wish -- but not recommend. Why use fragments over activities? Well fragments are wired to create reusable Android user inferences components -- however, it is true to say you can implement similar application UIs with a pure activity solution, which might be confusing for students. Here are some reasons why you should use fragments as a designer:</p>
<ul>
<li>Consider the diagram below. You are designing a cool new app that you want gazillions of people to use on all sorts of phones and tablets with different sized screens. The figure shows how your UI based on fragment design could run on a tablet and phone UI; in the case of the tablet with larger screen real estate the UI fragment components are rendered side by side but on the phone with a smaller form factor the two fragments are treated differently and brought into focus at different times. The activity that handles the UI is smart enough to adapt the UI to the type of device.</li>
</ul>
<div class="figure">
<img src="images/fragments.png">
</div>
<ul>
<li>As we will see in the sample project code ActionTab fragments have been integrated into UI components such as ActionBar which is a the recommend way to build a common UI feel across different apps. We will discuss ActionBar later in these notes where we <em>bind</em> tabs (to navigate your app) on the ActionBar to fragments. When we look at the callback (i.e., ActionBar.TabListener interface) for handling the event when the user taps a tab the interface passes a <code>FragmentTransaction</code> as an input argument to the onTabSelected method. In brief, many UI components assume you are using fragments and not activities -- as a result, fragments are wired into the UI and activities are not.</li>
</ul>
<h2 id="fragment-lifecycle">Fragment Lifecycle</h2>
<p>Though Fragment defines its own lifecycle, that lifecycle is dependent on its activity: if the activity is stopped, no fragments inside of it can be started; when the activity is destroyed, all fragments will be destroyed.</p>
<p>A fragment runs with in the activity and the activity lifecycle that we discussed. So it an activity is stopped so are all its fragments. Similarly if the activity is destroyed so are all the associated fragments. However, when an activity is <code>running</code> (i.e., onResume() state) fragments can be independently managed -- added, replaced or removed. As we will see what we discuss the ActionTab application we will use <em>fragment transactions</em> to remove and replace fragments associated with the action bar tabs: such as:</p>
<ul>
<li>ft.remove(fragment); remove a fragment from the UI</li>
<li>ft.replace(R.id.fragment_container, fragment); replace one fragment (or view) with another.</li>
</ul>
<p>These fragment transactions allow the activity to manage the <code>back stack</code> - a back stack entry in the activity is a record of the fragment transaction that occurred. This, for example, allows the user to reverse a fragment transaction (navigate backwards), by pressing the back button.</p>
<p>The <a href="http://developer.android.com/guide/components/fragments.html">fragment lifecycle</a> diagram shown below looks complicated but as we discuss it consider that this set of fragment states run inside of the running state of the activity lifecycle diagram we discussed in earlier lecture on activity lifecycle. Therefore the state diagram shown below is only valid when the activity associated with the fragment</p>
<div class="figure">
<img src="images/fragment-lifecycle.png">
</div>
<p>Like the activity lifecycle the fragment lifecycle is represented by a bunch of states and associated event handlers, which are triggered when a fragment is:</p>
<ul>
<li>created</li>
<li>resumed</li>
<li>paused</li>
<li>stopped</li>
<li>destroyed</li>
</ul>
<p>In addition there are a number of callbacks associated with a number of fragment specific events, such as, 1) binding and unbinding a fragment from its activity; 2) when a fragment is created and destroyed. If you look at the core states shown in the figure you see:</p>
<ul>
<li>fragment is added</li>
<li>fragment is active</li>
<li>fragment is destroyed</li>
</ul>
<h2 id="fragment-lifecycle-events">Fragment lifecycle events</h2>
<p>Many events can occur between these states -- for example the user can hit the back button.</p>
<ul>
<li>onAttach() is called when the Fragment is attached to its parent activity</li>
<li>onCreate() is called to initially create the fragment</li>
<li>onCreateView() is called to created its user interface -- it inflates the fragment UI</li>
<li>onActivityCreated() is called once the parent activity and the fragment UI are created.</li>
<li>onStart() is called the start of the visible lifetime, any UI changes can be applied before the fragment goes visible</li>
<li>onResume() is called at the start of the active lifetime such as resuming any paused UI updates needed by the fragment that were suspended when it became inactive.</li>
<li>onPause() called at the end of the active lifetime; persist all edits or state changes, suspend UI updates, threads, or CPU intensive processes that don't need to be updated when the Activity isn't the active foreground activity</li>
<li>onSaveInstanceState() called to save UI state changes at the end of the active lifecycle</li>
<li>void onStop() called at the end of the visible lifetime</li>
<li>onDestroyView() called when the fragment's view is detached</li>
<li>onDestroy() called at the end of the full lifetime</li>
<li>onDetach() called when the Fragment has been detached from its parent activity. <sub>~</sub>{.java}</li>
</ul>
<p>If we consider the ActionTab app it has four fragments - one for each tab view. As the use taps through the tab options the fragment transitions through the states in the lifecycle diagram -- moving say from being in focus in onResume() to hidden in onPause(). But the complete fragment lifecycle is tightly coupled to the activity but also governed by the user interaction with the UI (as is the case with the ActionTab app). The activity can dynamically construct the UI and its associated fragments -- such as adding and removing fragments where each fragment transitions through its full, visible and active lifecycle several times within the lifetime of its parent activity -- for example as a fragment is added and removed from the view.</p>
<p>See <a href="">MySkeletonFragment.java</a> for an example of a skeleton fragment. There are many events and we will only use a few of these events in terms of populating code. So don't be overwhelmed -- at least, not yet ;-). Let's discuss some of the important events.</p>
<h2 id="onattach-and-ondetach-events">onAttach() and onDetach() events</h2>
<p>The lifecycle starts and ends when a fragment is attached and detached from its parent activity. The onAttach() event occurs before the fragment's UI is created and before the fragment or its parent activity have completed initialization. Keep this in mind when we are looking at the ActionTab activity's onCreate() when it creates its fragments. It is a good idea to create fragments in the activities onCreate() to ensure they are created only once in the fragment lifetime.</p>
<h2 id="oncreateview-event">onCreateView() event</h2>
<p>The fragment's UI is created and destroyed in onCreateView() and onDestroyView() callbacks, respectively. The onCreateView() method initializes the fragment by inflating the UI, getting references and binding any data to the views that it contains -- and then any addition initialization such as setting up services (we will talk about services later on in the course).</p>
<h2 id="oncreateview-actiontab-example">onCreateView(): ActionTab example</h2>
<p>The onCreateView()'s main job in code we will write is a onliner -- taken from FindFragment.java in the ActionTab app:</p>
<pre class="sourceCode java"><code class="sourceCode java"><span class="kw">return</span> inflater.<span class="fu">inflate</span>(R.<span class="fu">layout</span>.<span class="fu">findfragment</span>, container, <span class="kw">false</span>)</code></pre>
<h2 id="an-example-of-a-fragment-layout">An example of a fragment layout</h2>
<p>The R.layout.findfragment is the ID for an XML layout resource to load (e.g., R.layout.findfragment). This is defined in the res/layout/findfragment.xml of the ActionTab project. This specifies the UI for the fragment, which is just a simple image but could be a sophisticated view group.</p>
<pre class="sourceCode java"><code class="sourceCode java">&lt;?xml version=<span class="st">&quot;1.0&quot;</span> encoding=<span class="st">&quot;utf-8&quot;</span>?&gt;
&lt;LinearLayout xmlns:android=<span class="st">&quot;http://schemas.android.com/apk/res/android&quot;</span>
    android:layout_width=<span class="st">&quot;match_parent&quot;</span>
    android:layout_height=<span class="st">&quot;match_parent&quot;</span>
    android:orientation=<span class="st">&quot;vertical&quot;</span> &gt;
 
    &lt;ImageView
        android:id=<span class="st">&quot;@+id/imageViewOfGirl&quot;</span>
        android:layout_width=<span class="st">&quot;fill_parent&quot;</span>
        android:layout_height=<span class="st">&quot;fill_parent&quot;</span>
        android:contentDescription=<span class="st">&quot;@string/ui_love_picture&quot;</span>
        android:orientation=<span class="st">&quot;horizontal&quot;</span>
        android:src=<span class="st">&quot;@drawable/ic_eye&quot;</span> /&gt;
 
&lt;/LinearLayout&gt;</code></pre>
<h2 id="placing-fragment-layouts-into-a-container-view-at-runtime">Placing fragment layouts into a container view at runtime</h2>
<p>The <code>container</code> parameter used in the inflate method is the optional view to be the parent of the generated hierarchy in this case the XML in res/layout/main.xml of the ActionTab project. This is shown below and represents a simple hierarchical LinearLayout where the fragment container is defined. ActionTab dynamically modifies layouts by adding, removing and replacing fragments at runtime. It does this by creating layouts such as findfragment.xml (and the other three layouts in ActionTab) at runtime and then load or placing them into a <em>container</em> View such as main.xml below. The app does this based on the user interaction -- and the system.</p>
<pre class="sourceCode java"><code class="sourceCode java">&lt;?xml version=<span class="st">&quot;1.0&quot;</span> encoding=<span class="st">&quot;utf-8&quot;</span>?&gt;
&lt;LinearLayout
xmlns:android=<span class="st">&quot;http://schemas.android.com/apk/res/android&quot;</span>
android:orientation=<span class="st">&quot;vertical&quot;</span>
android:layout_width=<span class="st">&quot;fill_parent&quot;</span>
android:layout_height=<span class="st">&quot;fill_parent&quot;</span> android:layout_gravity=<span class="st">&quot;center&quot;</span>&gt;
            &lt;LinearLayout
                android:id=<span class="st">&quot;@+id/fragment_container&quot;</span>
                android:layout_width=<span class="st">&quot;match_parent&quot;</span>
                android:layout_height=<span class="st">&quot;match_parent&quot;</span> &gt;
 
 &lt;/LinearLayout&gt;
&lt;/LinearLayout&gt;
 </code></pre>
<p>We will come back to these xml files when we discuss ActionTab in more detail. main.xml</p>
<h2 id="actionbar">ActionBar</h2>
<p>ActionBar is a simple UI component that can be used by many different applications -- it gives a common feel that can be customized to the specific needs on different applications. Let's take a closer look at the action bar of our app -- now shown in portrait mode, as shown below. The action bar shows the application icon on the left -- the CS logo, followed by the activity title -- ActionTab. Our activity defines a number of &quot;action items&quot; (in menu/main.xml). Selected items can be made visible on the action bar such as search and send (which are directly accessible as icons defined in the menu/main.xml). If a menu item does not appear as an action item (for example add, share, feedback) then the action bar places it in the overflow menu -- the action item icons and the overflow menu are down in the figure(left). The overflow menu button is show on far right of the figure -- 3 dots stacked. If we click on that we see the hidden menu options -- shown in the figure (right).</p>
<div class="figure">
<img src="images/menuitem.png" alt="fragments"><p class="caption">fragments</p>
</div>
<p>From your activity, you can retrieve an instance of ActionBar by calling getActionBar().</p>
<h2 id="setting-up-the-menu-with-action-items">Setting up the menu with action Items</h2>
<p>The menu declares all of the menu items. We show a few items below. The object ID is set up; note Android has a number of nice icons we can use and in the case below we use the search and send icons from @android:drawable; regards &quot;ifRoom&quot;: You can specify that a menu item appear as an action item in the XML file by using <code>android:showAsAction=&quot;ifRoom&quot;</code> as shown above in our menu for each of the <item> element. Depending on space (could be a tablet or phone, or could be a phone flipping between portrait and landscape) the item might be in the actionbar or if there is no room it will appear in the overflow menu. The final of the item set up is a title @string/ui_menu_send that can be used in the overflow menu if it can't be accommodated in the action bar.<p>
<pre class="sourceCode java"><code class="sourceCode java">&lt;?xml version=<span class="st">&quot;1.0&quot;</span> encoding=<span class="st">&quot;utf-8&quot;</span>?&gt;
&lt;menu xmlns:android=<span class="st">&quot;http://schemas.android.com/apk/res/android&quot;</span> &gt;
 
    &lt;item
        android:id=<span class="st">&quot;@+id/menuitem_search&quot;</span>
        android:icon=<span class="st">&quot;@android:drawable/ic_menu_search&quot;</span>
        android:showAsAction=<span class="st">&quot;ifRoom&quot;</span>
        android:title=<span class="st">&quot;@string/ui_menu_search&quot;</span>&gt;
    &lt;/item&gt;
    &lt;item
        android:id=<span class="st">&quot;@+id/menuitem_send&quot;</span>
        android:icon=<span class="st">&quot;@android:drawable/ic_menu_send&quot;</span>
        android:showAsAction=<span class="st">&quot;ifRoom&quot;</span>
        android:title=<span class="st">&quot;@string/ui_menu_send&quot;</span>&gt;
    &lt;/item&gt;
 
    **snippet**
&lt;/menu&gt;</code></pre>
<h2 id="creating-the-actionbar-and-tabs">Creating the ActionBar and Tabs</h2>
<p>We first get a reference to the actionBar and then set the navigation mode:</p>
<ul>
<li>NAVIGATION_MODE_TABS. This mode presents a series of tabs for navigation within the activity.</li>
</ul>
<p>There are two other navigation modes:</p>
<ul>
<li>NAVIGATION_MODE_LIST; this mode presents a list menu for navigation within the activity. e.g. this might be presented to the user as a dropdown list.</li>
<li>NAVIGATION_MODE_STANDARD; supports either a logo or icon and title text with an optional subtitle. Clicking any of these elements will dispatch onOptionsItemSelected to the host Activity with a MenuItem with item ID android.R.id.home.</li>
</ul>
<p>We create (and return) 4 ActionBar.Tab. These tabs will not be included in the action bar until they are added. The name of the tabs are stored in strings.xml and references here.</p>
<p>Our design uses tabs to switch between Fragment objects, as discussed below.</p>
<pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> MainActivity <span class="kw">extends</span> Activity {
 
            <span class="co">/** Called when the activity is first created. */</span>
            @Override
            <span class="kw">public</span> <span class="dt">void</span> <span class="fu">onCreate</span>(Bundle savedInstanceState) {
                        <span class="kw">super</span>.<span class="fu">onCreate</span>(savedInstanceState);
                        <span class="fu">setContentView</span>(R.<span class="fu">layout</span>.<span class="fu">main</span>);
 
                        <span class="co">// ActionBar</span>
                        ActionBar actionbar = <span class="fu">getActionBar</span>();
                        actionbar.<span class="fu">setNavigationMode</span>(ActionBar.<span class="fu">NAVIGATION_MODE_TABS</span>);
 
                        <span class="co">// create new tabs and set up the titles of the tabs</span>
                        ActionBar.<span class="fu">Tab</span> mFindTab = actionbar.<span class="fu">newTab</span>().<span class="fu">setText</span>(
                                                <span class="fu">getString</span>(R.<span class="fu">string</span>.<span class="fu">ui_tabname_find</span>));
                        ActionBar.<span class="fu">Tab</span> mChatTab = actionbar.<span class="fu">newTab</span>().<span class="fu">setText</span>(
                                                <span class="fu">getString</span>(R.<span class="fu">string</span>.<span class="fu">ui_tabname_chat</span>));
                        ActionBar.<span class="fu">Tab</span> mMeetTab = actionbar.<span class="fu">newTab</span>().<span class="fu">setText</span>(
                                                <span class="fu">getString</span>(R.<span class="fu">string</span>.<span class="fu">ui_tabname_meet</span>));
                        ActionBar.<span class="fu">Tab</span> mPartyTab = actionbar.<span class="fu">newTab</span>().<span class="fu">setText</span>(
                                                <span class="fu">getString</span>(R.<span class="fu">string</span>.<span class="fu">ui_tabname_party</span>));
 </code></pre>
<p>Once the tabs are set up we create 4 new fragments; we simply use the new key word in front of the class names for each of the fragments created in the files:</p>
<ul>
<li>ChatFragment.java</li>
<li>FindFragment.java</li>
<li>MeetFragment.java</li>
<li>PartyFragment.java</li>
</ul>
<p>These are all pretty much identical code. Each fragment inflates its own layout (e.g., R.layout.chatfragment) in onCreateView().</p>
<p>Next, we set up the TabListeners on each of the created tabs for each of the fragments. Note, the constructor passes the reference to the fragment and the application context, which is used by the callbacks to display toast. Once we have created new TabListener interfaces and bind the fragments we then add the tab to the ActionBar for each of the tabs.</p>
<pre class="sourceCode java"><code class="sourceCode java">                        <span class="co">// create the fragments</span>
                        Fragment mFindFragment = <span class="kw">new</span> <span class="fu">FindFragment</span>();
                        Fragment mChatFragment = <span class="kw">new</span> <span class="fu">ChatFragment</span>();
                        Fragment mMeetFragment = <span class="kw">new</span> <span class="fu">MeetFragment</span>();
                        Fragment mPartyFragment = <span class="kw">new</span> <span class="fu">PartyFragment</span>();
 
                        <span class="co">// bind the fragments to the tabs - set up tabListeners for each tab</span>
                        mFindTab.<span class="fu">setTabListener</span>(<span class="kw">new</span> <span class="fu">MyTabsListener</span>(mFindFragment,
                                                <span class="fu">getApplicationContext</span>()));
                        mChatTab.<span class="fu">setTabListener</span>(<span class="kw">new</span> <span class="fu">MyTabsListener</span>(mChatFragment,
                                                <span class="fu">getApplicationContext</span>()));
                        mMeetTab.<span class="fu">setTabListener</span>(<span class="kw">new</span> <span class="fu">MyTabsListener</span>(mMeetFragment,
                                                <span class="fu">getApplicationContext</span>()));
                        mPartyTab.<span class="fu">setTabListener</span>(<span class="kw">new</span> <span class="fu">MyTabsListener</span>(mPartyFragment,
                                                <span class="fu">getApplicationContext</span>()));
 
                        <span class="co">// add the tabs to the action bar</span>
                        actionbar.<span class="fu">addTab</span>(mFindTab);
                        actionbar.<span class="fu">addTab</span>(mChatTab);
                        actionbar.<span class="fu">addTab</span>(mMeetTab);
                        actionbar.<span class="fu">addTab</span>(mPartyTab);</code></pre>
<h2 id="creating-fragments-and-inflating-meetfragment.java-example">Creating fragments and inflating: MeetFragment.java example</h2>
<p>A fragment extends the Fragment class as shown below. When the MainActivity creates the fragments it calls onCreateView() for all fragments. All onCreateView() creates and returns the view hierarchy associated with the fragment-- essentially it returns the view for the fragment's UI. The code below overrides the onCreateView() handler into inflate and return the requires <em>view hierarchy</em>; that is, R.layout.meetfragment, as shown below. Note, if your fragment does not use a UI (such as providing the activity with background behavior) you do not inflate of course.</p>
<p>Importantly, fragments do not have to be registered in the manifest like activities are. And, as the fragment lifecycle, fragments are tied to the state of the activity so this makes good sense; that is, they can't exist without an activity.</p>
<pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> MeetFragment <span class="kw">extends</span> Fragment {
            
    @Override
    <span class="kw">public</span> View <span class="fu">onCreateView</span>(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        <span class="co">// Inflate the layout for this fragment</span>
        <span class="kw">return</span> inflater.<span class="fu">inflate</span>(R.<span class="fu">layout</span>.<span class="fu">meetfragment</span>, container, <span class="kw">false</span>);
    }
    
}</code></pre>
<h2 id="inflating-the-menu">Inflating the menu</h2>
<p>The onCreateOptionsMenu() callback is invoked when the activity is created to inflate the main.xml in the menu folder as discussed above -- this inflates the XML menu resources that populates the he action bar and overflow menu. You can add menu items to the menu programmatically using onCreateOptionsMenu() but in our example we simply inflate the items set up in main.xml.</p>
<pre class="sourceCode java"><code class="sourceCode java">            @Override
            <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">onCreateOptionsMenu</span>(Menu menu) {
                        MenuInflater inflater = <span class="fu">getMenuInflater</span>();
                        inflater.<span class="fu">inflate</span>(R.<span class="fu">menu</span>.<span class="fu">main</span>, menu);
                        <span class="kw">return</span> <span class="kw">true</span>;
            }</code></pre>
<h2 id="selecting-menu-items">Selecting menu items</h2>
<p>If you added the menu item from a fragment, via the Fragment class's onCreateOptionsMenu callback, then the system calls the respective onOptionsItemSelected() method for that fragment when the user selects one of the fragment's items. When any of the options are selected by the user the onOptionsItemSelected is called with the reference to the related MenuItem. In most cases the callback justs displays toast but in the case of quit we call <code>finish()</code> to close the app.</p>
<pre class="sourceCode java"><code class="sourceCode java">            @Override
            <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">onOptionsItemSelected</span>(MenuItem item) {
                        <span class="kw">switch</span> (item.<span class="fu">getItemId</span>()) {
                        <span class="kw">case</span> R.<span class="fu">id</span>.<span class="fu">menuitem_search</span>:
                                    Toast.<span class="fu">makeText</span>(<span class="kw">this</span>, <span class="fu">getString</span>(R.<span class="fu">string</span>.<span class="fu">ui_menu_search</span>),
                                                            Toast.<span class="fu">LENGTH_LONG</span>).<span class="fu">show</span>();
                                    <span class="kw">return</span> <span class="kw">true</span>;
                        <span class="kw">case</span> R.<span class="fu">id</span>.<span class="fu">menuitem_send</span>:
                                    Toast.<span class="fu">makeText</span>(<span class="kw">this</span>, <span class="fu">getString</span>(R.<span class="fu">string</span>.<span class="fu">ui_menu_send</span>),
                                                            Toast.<span class="fu">LENGTH_LONG</span>).<span class="fu">show</span>();
 
                        ** snippet**
 
                        <span class="kw">case</span> R.<span class="fu">id</span>.<span class="fu">menuitem_quit</span>:
                                    Toast.<span class="fu">makeText</span>(<span class="kw">this</span>, <span class="fu">getString</span>(R.<span class="fu">string</span>.<span class="fu">ui_menu_quit</span>),
                                                            Toast.<span class="fu">LENGTH_SHORT</span>).<span class="fu">show</span>();
                                    <span class="fu">finish</span>(); <span class="co">// close the activity</span>
                                    <span class="kw">return</span> <span class="kw">true</span>;
                        }
                        <span class="kw">return</span> <span class="kw">false</span>;
            }
 </code></pre>
<h2 id="implementing-the-actionbar.tablistener-interface">Implementing the ActionBar.TabListener interface:</h2>
<p>The activity implement the TabListener interface, since we are passing it into the setTabListener() method. There are three methods you must implement on that interface:</p>
<ul>
<li>onTabSelected() is called when the tab is selected by the user</li>
<li>onTabUnselected() is called when some other tab is selected by the user</li>
<li>onTabReselected() is called when the user taps on an already selected tab (e.g., to refresh the tab’s contents)</li>
</ul>
<p>When the user touches a tab the following MyTabsListener will be invoked -- different callbacks are invoked depending on the user action. Toast is included so you can see the action on the display as you use the application. For example, when the ActionTab starts the constructor sets up the fragment and context for each of the 4 tabs -- 4 objects are created by the MainActivity, as discussed earlier. Then onTabSelected is called for the default tab, which is the one in focus -- in this case, the find tab.</p>
<p>If the user selects <em>find</em> again then the: onTabReselected() callback is invoked. There is nothing in this callback other than some toast. If the user then selects <em>chat</em> then the following actions take place:</p>
<ul>
<li><p>the first action is to unselect the find fragment, which is currently displayed -- this happens when the onTabUnselected() is invoked. Note, in onTabUnselected() the code calls ft.remove(fragment); -- which is a fragment transaction to remove the current fragment which in this case is the <em>find</em> fragment.</p></li>
<li><p>the second action is to select the new fragment associated with the <em>chat</em> tab; onTabSelected() is called and the callback calls <em>ft.replace(R.id.fragment_container, fragment)</em> which is a fragment transaction to replace the current fragment with that which is passed as parameters -- that is, R.id.fragment_container, fragment); where R.id.fragment_container is R.layout.chatfragment (inflated in onCreateView()) and fragment is <em>ChatFragment.java</em>. Each MyTabsListener has a tuple of the fragment_container and fragment setup on creation.</p></li>
</ul>
<p>Tab switching is managed by using the TabListener through the creation of <strong>fragment transactions</strong> in response to the user tapping the tabs; that is the user <em>selects, unselects</em>, and <em>reselects tabs</em>. These fragment transactions are managed inside of the TabListenser interface, shown below. If you look at the interface it comprises the constructor and the tab selected, unselected and reselected. A new fragment is only added in the onTabSelected() where the ft.replace(R.id.fragment_container, fragment) is invoked to switch fragments and views.</p>
<pre class="sourceCode java"><code class="sourceCode java"><span class="kw">class</span> MyTabsListener <span class="kw">implements</span> ActionBar.<span class="fu">TabListener</span> {
            <span class="kw">public</span> Fragment fragment;
            <span class="kw">public</span> Context context;
 
            <span class="kw">public</span> <span class="fu">MyTabsListener</span>(Fragment fragment, Context context) {
                        <span class="kw">this</span>.<span class="fu">fragment</span> = fragment;
                        <span class="kw">this</span>.<span class="fu">context</span> = context;
 
            }
 
            @Override
            <span class="kw">public</span> <span class="dt">void</span> <span class="fu">onTabReselected</span>(Tab tab, FragmentTransaction ft) {
                        Toast.<span class="fu">makeText</span>(context, <span class="st">&quot;Reselected!&quot;</span>, Toast.<span class="fu">LENGTH_SHORT</span>).<span class="fu">show</span>();
 
            }
 
            @Override
            <span class="kw">public</span> <span class="dt">void</span> <span class="fu">onTabSelected</span>(Tab tab, FragmentTransaction ft) {
                        Toast.<span class="fu">makeText</span>(context, <span class="st">&quot;Selected!&quot;</span>, Toast.<span class="fu">LENGTH_SHORT</span>).<span class="fu">show</span>();
                        ft.<span class="fu">replace</span>(R.<span class="fu">id</span>.<span class="fu">fragment_container</span>, fragment);
            }
 
            @Override
            <span class="kw">public</span> <span class="dt">void</span> <span class="fu">onTabUnselected</span>(Tab tab, FragmentTransaction ft) {
                        Toast.<span class="fu">makeText</span>(context, <span class="st">&quot;Unselected!&quot;</span>, Toast.<span class="fu">LENGTH_SHORT</span>).<span class="fu">show</span>();
                        ft.<span class="fu">remove</span>(fragment);
            }
            
}</code></pre>
<h2 id="saving-temporary-app-state">Saving temporary app state</h2>
<p>The method onSaveInstanceState(Bundle) is called before placing the activity into background, allowing you to save dynamic instance state in your activity into the given Bundle. This can be used later in onCreate(Bundle) if the activity needs to be re-created. onSaveInstanceState() is used to &quot;remember&quot; the current state when a configuration change occurs such screen orientation change. This is not meant for &quot;long term persistence&quot;. We store the tab navigation here and restore it in onCreate().</p>
<pre class="sourceCode java"><code class="sourceCode java">            @Override
            <span class="kw">protected</span> <span class="dt">void</span> <span class="fu">onSaveInstanceState</span>(Bundle outState) {
                        <span class="kw">super</span>.<span class="fu">onSaveInstanceState</span>(outState);
                        Toast.<span class="fu">makeText</span>(
                                                <span class="kw">this</span>,
                                                <span class="st">&quot;onSaveInstanceState: tab is&quot;</span>
                                                                        + <span class="fu">getActionBar</span>().<span class="fu">getSelectedNavigationIndex</span>(),
                                                Toast.<span class="fu">LENGTH_SHORT</span>).<span class="fu">show</span>();
                        outState.<span class="fu">putInt</span>(TAB_KEY_INDEX, <span class="fu">getActionBar</span>()
                                                .<span class="fu">getSelectedNavigationIndex</span>());
 
            }</code></pre>
<h2 id="what-is-context">What is Context?</h2>
<p>In code examples you will see <code>Context</code> being passed around frequent. But what is context? Context is the current state of the application, activity, and object. It allows newly created objects to understand what has been going on. An application or its related activities have access to underlying system resources. You need that context to get at those services. Context is an entity that represents various environment data: local files, databases, class loaders associated to the environment, services including system-level services, and more. The application and activities inherit the Context object. Typically, you will need to get an reference to the Context to get information regarding the current object (this) or another part of your program (activity, package/application).</p>
<p>You can get the context a number of different ways by invoking</p>
<ul>
<li>getApplicationContext() -- application context</li>
<li>getContext() -- another way to get application context</li>
<li>getBaseContext() -- activity context</li>
<li><strong>this</strong> when in the activity class.</li>
</ul>
<p>As a fairly simple run use this or getApplicationContext() to get a reference to Context object. This is a dumb and simple rule but may not always work/</p>
<p>Here are a couple of examples:</p>
<pre class="sourceCode java"><code class="sourceCode java">            <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">onOptionsItemSelected</span>(MenuItem item) {
                        <span class="kw">switch</span> (item.<span class="fu">getItemId</span>()) {
                        <span class="kw">case</span> R.<span class="fu">id</span>.<span class="fu">menuitem_search</span>:
                                    Toast.<span class="fu">makeText</span>(<span class="kw">this</span>, <span class="fu">getString</span>(R.<span class="fu">string</span>.<span class="fu">ui_menu_search</span>),
                                                            Toast.<span class="fu">LENGTH_LONG</span>).<span class="fu">show</span>();
                                    <span class="kw">return</span> <span class="kw">true</span>;</code></pre>
<p>Because onOptionsItemSelected() is in the context of the activity it uses <code>this</code> in the toast above. This <code>this</code> is the activity context that has access to the resources such as R.string.ui_menu_search for example.</p>
<p>But what happens in the case where the code does not have access to the context? Here is the next example. Consider the TabListener interface. Here you cannot use <code>this</code> because it does not refer to the MainActivity (which is what you want to display the toast) but the handler. Therefore, because you need the Context of the MainActivity you need to have that set up before as we do in the code.</p>
<p>Because the MyTabsListener is outside the scope of the MainActivity and listener needs to get the context to display toast we pass the application context getApplicationContext() in onCreate() of the MainActivity to the MyTabsListener constructor and save it in context -- for use later in the toast.</p>
<p>First we pass the getApplicationContext() to the MyTabsListener constructor in the MainActivity's onCreate() as shown below.</p>
<pre class="sourceCode java"><code class="sourceCode java">                        <span class="co">// bind the fragments to the tabs - set up tabListeners for each tab</span>
                        mFindTab.<span class="fu">setTabListener</span>(<span class="kw">new</span> <span class="fu">MyTabsListener</span>(mFindFragment,
                                                <span class="fu">getApplicationContext</span>()));</code></pre>
<p>Again the contructor saves the application context and uses it in toast. In this example an activity passes Context to a handler. Toast and other objects such as Intents, both requires reference to context. That is what drives this example.</p>
<pre class="sourceCode java"><code class="sourceCode java"><span class="kw">class</span> MyTabsListener <span class="kw">implements</span> ActionBar.<span class="fu">TabListener</span> {
            <span class="kw">public</span> Fragment fragment;
            <span class="kw">public</span> Context context;
 
            <span class="kw">public</span> <span class="fu">MyTabsListener</span>(Fragment fragment, Context context) {
                        <span class="kw">this</span>.<span class="fu">fragment</span> = fragment;
                        <span class="kw">this</span>.<span class="fu">context</span> = context;
 
            }
 
            @Override
            <span class="kw">public</span> <span class="dt">void</span> <span class="fu">onTabSelected</span>(Tab tab, FragmentTransaction ft) {
                        Toast.<span class="fu">makeText</span>(context, <span class="st">&quot;Selected!&quot;</span>, Toast.<span class="fu">LENGTH_SHORT</span>).<span class="fu">show</span>();
                        ft.<span class="fu">replace</span>(R.<span class="fu">id</span>.<span class="fu">fragment_container</span>, fragment);
            }</code></pre>
<h2 id="which-context-to-use">Which context to use?</h2>
<p>There are two types of Context as discussed before.</p>
<p><strong>Application context</strong> is associated with the application and will always be same throughout the life of application -- it does not change. So if you are using Toast, you can use application context or even activity context (both) because toast can be displayed from anywhere with in your application and is not attached to a specific window. In the example above we simply want the handler display toast so application context makes sense. But there are many exceptions, one exception is when you need to use or pass the activity context.</p>
<p><strong>Activity context</strong> is associated with to the activity and can be destroyed if the activity is destroyed -- there may be multiple activities (more than likely) with a single application. And sometimes you absolutely need the activity context handle. For example, should you launch a new activity, you need to use activity context in its Intent so that the new launching activity is connected to the current activity in terms of activity stack. However, you may use application's context too to launch a new activity but then you need to set flag Intent.FLAG_ACTIVITY_NEW_TASK in intent to treat it as a new task.</p>
<p>So now we have discussed that let's consider some cases:</p>
<p><em>MainActivity.this</em> refers to the MainActivity context which extends Activity class but the base class (activity) also extends Context class, so it can be used to offer activity context.</p>
<p><em>getBaseContext()</em> offers activity context.</p>
<p><em>getApplication()</em> offers application context.</p>
<p><em>getApplicationContext()</em> also offers application context.</p>
<p>Because various components can run inside the context of an app, activity it is sometimes not clear how to get a hold of the context. For example, assume an activity starts up a fragment and you want to use toast inside the fragment - in this case use <code>getActivity()</code> which returns the activity associated with the fragment (see example code below for a ListFragment).</p>
<pre class="sourceCode java"><code class="sourceCode java">            <span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> TitlesFragment <span class="kw">extends</span> ListFragment {
                        <span class="dt">boolean</span> mDualPane;
                        <span class="dt">int</span> mCurCheckPosition = <span class="dv">0</span>;
 
                        @Override
                        <span class="kw">public</span> <span class="dt">void</span> <span class="fu">onActivityCreated</span>(Bundle savedInstanceState) {
                                    <span class="kw">super</span>.<span class="fu">onActivityCreated</span>(savedInstanceState);
 
                                    <span class="co">// You can use getActivity(), which returns the activity associated</span>
                                    <span class="co">// with a fragment.</span>
                                    <span class="co">// The activity is a context (since Activity extends Context) .</span>
 
                                    Toast.<span class="fu">makeText</span>(<span class="fu">getActivity</span>(), <span class="st">&quot;TitlesFragment&quot;</span>, Toast.<span class="fu">LENGTH_SHORT</span>)
                                                            .<span class="fu">show</span>();
 </code></pre>
</item></body>
</html>
